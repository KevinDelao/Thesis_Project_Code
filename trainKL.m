%% Run classification on different gesture sets saving test set results
%% and classifiers generated to savePath
% Trains: KNN, LDA, SVM-RBF, SVM-L and DT classifiers (see readme)
% Requires features to have been extracted with extractFeatures.m
% Requires gesture array to be updated by extractGesture.m
% Requires repetition array to be updated by extractRepetition.m
% Requires a gestureOrder array generated by getGestureOrders.m
%
% Estimated run time: Days (10min - 8 hours per gesture set depending on number of gestures)
% Optionally classifiers can be saved (uncomment code) however these files will be large (up to >300mb)


%% Housekeeping
clear; clc;

%% Settings
addpath('db1_feat') % Database path: ***EDIT ACCORDIGNLY***
addpath('gesture') % Gesture array path: ***EDIT ACCORDIGNLY***
addpath('gestureOrders') % Gesture order array path: ***EDIT ACCORDIGNLY***
addpath('repetition') % Repetition array path: ***EDIT ACCORDIGNLY***

savePath = 'results_temp'; % Save path: ***EDIT ACCORDIGNLY***

gestureOrderPair = {'gestureOrderKLDivergenceVAR' 'KL'} ;  % File_name-label for gesture order: ***EDIT ACCORDIGNLY***

featureSets = {'VAR' 'emgVAR'; % Easily expandable to more feature-array_name pairs
               %'MDWT' 'emgMDWT' % Example extension
               };

knnNeighbours = 10;
subSampleRate = 10;
standardise = true;

%% Important stuff
rng(1); % For reproducibility, seed the data

%% Output Data
predictions = cell(27,size(featureSets,1),5);
classifiers = cell(27,size(featureSets,1),5);
testClassesAll = cell(27,1);
%number of feats
feature = 1;
 for subject=1:1
     predList = {};
     testClassesAll={};
     tic
     disp('Subject:');
     disp(subject);
     %load gesture ordering per subject
    eval(['load ' gestureOrderPair{1}]); % Load gesture order
    eval(['load s' num2str(subject) '_feat.mat']); % Load data
    eval(['load s' num2str(subject) '_rep.mat']); % Load relabelled repetitions
    eval(['load s' num2str(subject) '_gestureMajority.mat']); % Load gestures (majority)
    subjectAccuracy = [];
    
     %% Data Split (Indices)
    %will need to be adjusted for other databases
    trainReps = [1 3 5 7 9];
    testingReps = [2 4 6 8 10];
    count =1;
    temp = gesture;
    temprep = rep;
    for k=1:size(gestureOrder,2)
         gesture=temp;
         rep = temprep;
         numGesturesToUse = k;
         unUsedGestures = gestureOrder(subject,numGesturesToUse:end);
         indicesToRemove = ismember(gesture,unUsedGestures);
         gesture(indicesToRemove) = [];
         rep(indicesToRemove) = [];
         indicesToRemove=[];

         numGestures = numel(unique((gesture)));
         numGestures = numel(unique((gesture)));
         numSamples = numel(gesture);
         trainIndices = ismember(rep,trainReps);
         testIndices = ismember(rep,testingReps);
           %% Subsample training data
            i = 1;
            for m = 1:numel(trainIndices)
                if mod(i,subSampleRate)
                    trainIndices(m) = 0;
                end
                i = i + 1;
            end
            %% Resample training data so rest has as many examples as the next most represented class
            %% need to do this so data is not biased towards rest
            trainCounts = histc(gesture(trainIndices),unique(gesture));
            maxGestureExamples = max(trainCounts(1:end-1)); % NOTE: unique still returns list in ascending order

            trainRestIndices = find(gesture == 53 & trainIndices == true);

            tempIndex = randperm(numel(trainRestIndices));
            indicesToRemove = trainRestIndices(tempIndex(maxGestureExamples+1:end));
            trainIndices(indicesToRemove) = 0;

            eval(['dataSet = ' featureSets{feature,2} ';']);

            %% Data Split Actual
            trainingData = dataSet(trainIndices,:);
            trainingClasses = gesture(trainIndices);
            numTraining = numel(trainingClasses);

            testData = dataSet(testIndices,:);
            testClasses = gesture(testIndices);
            numTesting = numel(testClasses);
            
            %% SVM classifier (rbf)
            templateRBFSVM = templateSVM(...
                'KernelFunction', 'rbf', ...
                'PolynomialOrder', [], ...
                'KernelScale', 'auto', ...
                'BoxConstraint', 1, ...
                'Standardize', standardise);

            classificationRBFSVM = fitcecoc(...
                trainingData, ...
                trainingClasses, ...
                'Learners', templateRBFSVM, ...
                'Coding', 'onevsall');
            rbfSVMPredictions = predict(classificationRBFSVM,testData);

            count = count+1;
            predList(k,1)={rbfSVMPredictions};
            testClassesAll{k,1} = testClasses;


    end
    
 save([savePath '\predictions' featureSets{feature,1} gestureOrderPair{2} num2str(subject) '.mat'] ...
            ,'predList','testClassesAll');       
 end
trainTime = toc;
disp(trainTime)
 
 
 
 
 
 
 
 
 